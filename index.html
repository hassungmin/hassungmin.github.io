<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Pro Palletizer: Smart Fit & Optimizer</title>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

<style>
  :root {
    --primary: #0f4c81;
    --success: #2e7d32;
    --warning: #ed6c02;
    --bg: #f4f6f8;
    --card: #ffffff;
    --text: #333;
    --border: #ccc;
  }

  body {
    font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
    background: var(--bg);
    color: var(--text);
    padding: 20px;
  }

  .container {
    background: var(--card);
    max-width: 100%;
    margin: 0 auto;
    border-radius: 8px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    padding: 25px;
  }

  h1 { text-align: center; color: var(--primary); margin-top: 0; margin-bottom: 25px; }

  .grid-2 {
    display: grid;
    grid-template-columns: 350px 1fr;
    gap: 25px;
  }
  @media (max-width: 1100px) { .grid-2 { grid-template-columns: 1fr; } }

  .panel {
    border: 1px solid var(--border); padding: 15px;
    border-radius: 6px; background: #fdfdfd; margin-bottom: 20px;
  }
  
  .panel-title {
    font-weight: bold; color: var(--primary); border-bottom: 2px solid #eee;
    padding-bottom: 8px; margin-bottom: 15px; display: block;
  }

  label { display: block; margin-top: 10px; font-weight: 600; font-size: 0.9rem; }
  
  input[type="number"], select, input[type="file"] {
    width: 100%; padding: 8px; margin-top: 5px;
    border: 1px solid #aaa; border-radius: 4px; box-sizing: border-box;
  }
  input[readonly] { background-color: #e9ecef; color: #555; }

  button {
    background: var(--primary); color: white; border: none;
    padding: 12px 20px; width: 100%; font-size: 1rem; cursor: pointer;
    border-radius: 4px; margin-top: 15px; font-weight: bold;
  }
  button:hover { background: #0a355c; }
  .btn-download { background: #d32f2f; margin-top: 10px; display: none; }
  .btn-download:hover { background: #b71c1c; }

  #canvasWrapper {
    width: 100%;
    overflow-x: auto;
    overflow-y: hidden;
    background: #eee;
    padding: 20px;
    border: 1px solid #999;
    min-height: 550px; 
    display: flex;
    align-items: flex-start;
  }
  
  canvas { background: white; box-shadow: 0 0 15px rgba(0,0,0,0.1); display: block; cursor: default; }

  .table-scroll { max-height: 400px; overflow-y: auto; font-size: 0.85rem; }
  table { width: 100%; border-collapse: collapse; }
  th, td { border: 1px solid #ddd; padding: 6px; text-align: center; }
  th { background-color: var(--primary); color: white; position: sticky; top: 0; }
  
  .summary-bar {
    display: flex; gap: 20px; background: #e3f2fd;
    padding: 15px; border-radius: 5px; margin-bottom: 15px; font-size: 1rem;
    align-items: center; justify-content: space-around;
  }
  .big-stat { font-size: 1.4rem; font-weight: bold; color: var(--primary); }

  .suggestion-box {
    margin-top: 15px; padding: 15px; border-radius: 6px;
    display: none; 
  }
  .suggest-good { background-color: #e8f5e9; border: 1px solid #a5d6a7; color: #2e7d32; }
  .suggest-better { background-color: #fff3e0; border: 1px solid #ffcc80; color: #e65100; }
  .suggestion-header { font-weight: bold; font-size: 1.1rem; margin-bottom: 5px; display: block;}

</style>
</head>
<body>

<div class="container">
  <h1>Palletizer: Smart Fit & Optimizer</h1>
  
  <div class="grid-2">
    <div>
      <div class="panel">
        <span class="panel-title">1. Default ULD Configuration</span>
        <label>Primary Unit Type</label>
        <select id="uldSelect" onchange="updateULD()">
          <option value="LD3">LD3 (153x156)</option>
          <option value="PMC" selected>PMC (303x230)</option>
          <option value="PAG">PAG (303x209)</option>
          <option value="PZA">PZA (483x230)</option>
          <option value="PGA20">PGA 20ft (604x245)</option>
          <option value="PLA">PLA (303x140)</option>
        </select>

        <div style="display:grid; grid-template-columns:1fr 1fr 1fr; gap:5px;">
          <div><label>L</label><input id="cL" type="number" readonly></div>
          <div><label>W</label><input id="cW" type="number" readonly></div>
          <div><label>H</label><input id="cH" type="number" readonly></div>
        </div>
        
        <label style="margin-top:15px; display:flex; align-items:center;">
          <input type="checkbox" id="chkStackable" checked style="width:auto; margin-right:10px;">
          Enable Stacking? (Max 2 Layers)
        </label>
      </div>

      <div class="panel">
        <span class="panel-title">2. Upload Cargo</span>
        <input type="file" id="csvFile" accept=".csv">
        <button onclick="processCSV()">Generate Load Plan</button>
        <button id="btnDownloadPDF" class="btn-download" onclick="downloadPDF()">Download Visual & Manifest PDF</button>
      </div>
      <div id="errorLog" style="color:black; font-size:0.85rem; margin-top:5px; border: 1px solid transparent; padding: 8px; border-radius: 4px; line-height: 1.4;"></div>
    </div>

    <div>
      <div class="panel" style="border-left: 4px solid var(--primary);">
        <span class="panel-title">Load Summary</span>
        <div class="summary-bar">
          <div>Total Items: <br><span id="statTotalItems" class="big-stat">0</span></div>
          <div>Pallets Used: <br><span id="statPalletCount" class="big-stat" style="color:#d32f2f;">0</span></div>
          <div>Vol Efficiency: <br><span id="statEfficiency" class="big-stat">0%</span></div>
        </div>
        <div id="optimizationPanel" class="suggestion-box"></div>
      </div>

      <div class="panel" id="export-visual">
        <span class="panel-title">Visual Layout <small style="font-weight:normal; color:#666;">(Drag to move | Double-click to rotate)</small></span>
        <div id="canvasWrapper">
          <canvas id="loadCanvas"></canvas>
        </div>
      </div>
      
      <div class="panel" id="export-manifest">
        <span class="panel-title">Manifest Details</span>
        <div class="table-scroll">
          <table id="resultTable">
            <thead>
              <tr>
                <th>Pallet #</th>
                <th>Type</th>
                <th>ID</th>
                <th>Dims (LxDxH)</th>
                <th>Stack</th>
              </tr>
            </thead>
            <tbody></tbody>
          </table>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  // --- CORE DATA ---
  const ulds = {
    LD3:   { name:"LD3", l: 153, w: 156, h: 163 },
    PMC:   { name:"PMC", l: 303, w: 230, h: 290 },
    PAG:   { name:"PAG", l: 303, w: 209, h: 290 },
    PZA:   { name:"PZA", l: 483, w: 230, h: 290 },
    PGA20: { name:"PGA20", l: 604, w: 245, h: 290 },
    PLA:   { name:"PLA", l: 303, w: 140, h: 290 } 
  };
  let allPalletLoads = []; 
  let globalOversizedItems = []; // To track crates that didn't fit
  
  // Interaction variables
  let isDragging = false;
  let draggedStack = null;
  let draggedItem = null; // NEW: for individual item dragging
  let draggedPallet = null; 
  let originalPallet = null; 
  let originalStack = null; // NEW: track original stack when dragging individual items
  let originalPos = { x: 0, y: 0 }; 
  let dragOffset = { x: 0, y: 0 }; 
  let ghostGlobalPos = { x: 0, y: 0 }; 
  let isDraggingInvalid = false; // NEW: for invalid cargo dragging
  let draggedInvalidItem = null; // NEW: for invalid cargo dragging
  let invalidAreaBounds = null; // NEW: to store invalid area bounds

  let globalScale = 1;
  let isCurrentPosInvalid = false;
  const PADDING = 40;
  const GAP = 80;
  const BOX_START_Y = 50;

  window.onload = function() { 
    updateULD(); 
    initInteractions();
  };

  function updateULD() {
    const type = document.getElementById("uldSelect").value;
    const data = ulds[type];
    document.getElementById("cL").value = data.l;
    document.getElementById("cW").value = data.w;
    document.getElementById("cH").value = data.h;
    const canvas = document.getElementById("loadCanvas");
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width, canvas.height);
    canvas.width=0; canvas.height=0;
    document.getElementById("resultTable").querySelector("tbody").innerHTML = "";
    document.getElementById("statTotalItems").innerText = "0";
    document.getElementById("statPalletCount").innerText = "0";
    document.getElementById("statEfficiency").innerText = "0%";
    document.getElementById("optimizationPanel").style.display = "none";
    document.getElementById("btnDownloadPDF").style.display = "none";
    document.getElementById("errorLog").innerHTML = "";
    document.getElementById("errorLog").style.borderColor = "transparent";
    document.getElementById("errorLog").style.backgroundColor = "transparent";
    globalOversizedItems = [];
  }

  function processCSV() {
    const fileInput = document.getElementById("csvFile");
    const errorDiv = document.getElementById("errorLog");
    errorDiv.innerText = "";
    if (!fileInput.files.length) { errorDiv.innerText = "Please select a file."; return; }
    const reader = new FileReader();
    reader.onload = (e) => runMainSimulation(e.target.result);
    reader.readAsText(fileInput.files[0]);
    document.getElementById("btnDownloadPDF").style.display = "block";
  }

  function parseCSV(text) {
    const lines = text.split('\n');
    const res = [];
    lines.forEach(line => {
      let cl = line.trim();
      if(!cl) return;
      const parts = cl.split(/[,\t]+/);
      if(parts.length >= 4) {
         const l = parseFloat(parts[1]);
         const d = parseFloat(parts[2]);
         const h = parseFloat(parts[3]);
         if(!isNaN(l)) res.push({ id: parts[0], l:l, d:d, h:h });
      }
    });
    return res;
  }

  function findBestULD(item) {
    const itemW = Math.min(item.l, item.d);
    const itemL = Math.max(item.l, item.d);
    let bestFit = null;
    let minDeadSpace = Infinity;
    for (const key in ulds) {
      const u = ulds[key];
      let fit = (itemW <= u.w && itemL <= u.l && item.h <= u.h);
      if (fit) {
        const deadSpace = (u.w * u.l) - (itemW * itemL);
        if (deadSpace < minDeadSpace) { minDeadSpace = deadSpace; bestFit = u; }
      }
    }
    return bestFit;
  }

  function canItemFitInULD(item, uldData) {
    const itemW = Math.min(item.l, item.d);
    const itemL = Math.max(item.l, item.d);
    return (itemW <= uldData.w && itemL <= uldData.l && item.h <= uldData.h);
  }

  function findAllFloorPositions(w, h, binW, binH, rects) {
    let candidates = [{x:0, y:0}];
    
    // Generate candidate positions from existing rectangles
    rects.forEach(r => {
      candidates.push(
        { x: r.x + r.visualW, y: r.y },
        { x: r.x, y: r.y + r.visualH },
        { x: r.x + r.visualW, y: 0 },
        { x: 0, y: r.y + r.visualH }
      );
    });
    
    // Filter valid positions (no collision and within bounds)
    let validPositions = [];
    for (let p of candidates) {
      if (p.x + w <= binW && p.y + h <= binH) {
        let collision = false;
        for (let r of rects) {
          if (p.x < r.x + r.visualW && p.x + w > r.x && 
              p.y < r.y + r.visualH && p.y + h > r.y) {
            collision = true;
            break;
          }
        }
        if (!collision) {
          validPositions.push(p);
        }
      }
    }
    
    return validPositions;
  }

  function selectBestPosition(positions, w, h, binW, binH, rects) {
    if (positions.length === 0) return null;
    
    // Score each position based on multiple heuristics
    let scoredPositions = positions.map(pos => {
      let score = 0;
      
      // Prefer bottom-left (lower y, then lower x)
      score -= pos.y * 100;
      score -= pos.x * 10;
      
      // Prefer positions that touch existing rectangles (reduce fragmentation)
      let touchCount = 0;
      for (let r of rects) {
        // Check if touching on any side
        if ((Math.abs(pos.x - (r.x + r.visualW)) < 0.1 && pos.y < r.y + r.visualH && pos.y + h > r.y) ||
            (Math.abs((pos.x + w) - r.x) < 0.1 && pos.y < r.y + r.visualH && pos.y + h > r.y) ||
            (Math.abs(pos.y - (r.y + r.visualH)) < 0.1 && pos.x < r.x + r.visualW && pos.x + w > r.x) ||
            (Math.abs((pos.y + h) - r.y) < 0.1 && pos.x < r.x + r.visualW && pos.x + w > r.x)) {
          touchCount++;
        }
      }
      score += touchCount * 500;
      
      // Prefer positions against walls
      if (pos.x === 0) score += 300;
      if (pos.y === 0) score += 300;
      if (pos.x + w === binW) score += 200;
      if (pos.y + h === binH) score += 200;
      
      // Calculate wasted space (horizontal and vertical)
      let wastedHorizontal = binW - (pos.x + w);
      let wastedVertical = binH - (pos.y + h);
      score -= wastedHorizontal * 5;
      score -= wastedVertical * 5;
      
      return { pos, score };
    });
    
    // Sort by score (highest first)
    scoredPositions.sort((a, b) => b.score - a.score);
    
    return scoredPositions[0].pos;
  }

  function packItems(uldData, itemsInput, allowStacking) {
    let remainingItems = JSON.parse(JSON.stringify(itemsInput));
    let palletLoads = [];
    let oversizedItems = [];

    // Improved sorting: prioritize larger items and consider both dimensions
    remainingItems.sort((a, b) => {
        const areaA = a.l * a.d;
        const areaB = b.l * b.d;
        const maxDimA = Math.max(a.l, a.d);
        const maxDimB = Math.max(b.l, b.d);
        // Sort by area first, then by max dimension, then by height
        return (areaB - areaA) || (maxDimB - maxDimA) || (b.h - a.h);
    });

    let safety = 0;
    while(remainingItems.length > 0 && safety < 1000) {
      safety++;
      let currentULD = { ...uldData }; 
      let currentStacks = [];
      let nextPassItems = [];
      const firstItem = remainingItems[0];
      
      // Check if first item can fit in current ULD
      if (!canItemFitInULD(firstItem, currentULD)) {
        // Try to find a better ULD
        const smartULD = findBestULD(firstItem);
        if (smartULD) {
          currentULD = smartULD;
          currentULD.isSmartFit = true;
        } else {
          // Item is oversized for all available ULDs
          oversizedItems.push(firstItem);
          remainingItems.shift();
          continue;
        }
      }

      // Try to place each item
      for (let item of remainingItems) {
        let placed = false;
        
        // First check if item can fit in current ULD at all
        if (!canItemFitInULD(item, currentULD)) {
          nextPassItems.push(item);
          continue;
        }
        
        const visW = Math.min(item.l, item.d); 
        const visH = Math.max(item.l, item.d);

        // Try stacking first (if enabled)
        if (allowStacking) {
          let bestStackMatch = null;
          let bestStackScore = -1;
          
          for (let stack of currentStacks) {
            if (stack.items.length === 1) {
              const bottom = stack.items[0];
              if (visW <= bottom.visualW && visH <= bottom.visualH && 
                  (stack.currentH + item.h <= currentULD.h)) {
                // Calculate how well this item fits on this stack
                let wastedArea = (bottom.visualW * bottom.visualH) - (visW * visH);
                let score = 10000 - wastedArea; // Prefer tighter fits
                if (score > bestStackScore) {
                  bestStackScore = score;
                  bestStackMatch = stack;
                }
              }
            }
          }
          
          if (bestStackMatch) {
            bestStackMatch.items.push(item);
            bestStackMatch.currentH += item.h;
            item.visualW = visW;
            item.visualH = visH;
            item.x = bestStackMatch.x;
            item.y = bestStackMatch.y;
            item.z = bestStackMatch.currentH - item.h;
            placed = true;
          }
        }
        
        // If not stacked, try floor placement with improved algorithm
        if (!placed) {
          let positions = findAllFloorPositions(visW, visH, currentULD.w, currentULD.l, currentStacks);
          let pos = selectBestPosition(positions, visW, visH, currentULD.w, currentULD.l, currentStacks);
          
          if (pos) {
            currentStacks.push({ 
              x: pos.x, 
              y: pos.y, 
              visualW: visW, 
              visualH: visH, 
              currentH: item.h, 
              items: [item] 
            });
            item.visualW = visW;
            item.visualH = visH;
            item.x = pos.x;
            item.y = pos.y;
            item.z = 0;
            placed = true;
          }
        }
        
        if (!placed) {
          nextPassItems.push(item);
        }
      }

      // If nothing could be placed, check if items are oversized
      if (currentStacks.length === 0 && remainingItems.length > 0) {
        // All remaining items are oversized
        for (let item of remainingItems) {
          if (!canItemFitInULD(item, uldData)) {
            oversizedItems.push(item);
          } else {
            nextPassItems.push(item);
          }
        }
        remainingItems = nextPassItems;
        if (remainingItems.length === 0) break;
        continue;
      }
      
      if (currentStacks.length > 0) {
        palletLoads.push({ 
          uldName: currentULD.name, 
          uldW: currentULD.w, 
          uldL: currentULD.l, 
          uldH: currentULD.h, 
          isSmartFit: currentULD.isSmartFit || false, 
          stacks: currentStacks 
        });
      }
      remainingItems = nextPassItems;
    }
    
    // Final check: any remaining items that couldn't be placed are oversized
    for (let item of remainingItems) {
      if (!canItemFitInULD(item, uldData)) {
        oversizedItems.push(item);
      }
    }
    
    return { loads: palletLoads, remaining: oversizedItems };
  }

  function runMainSimulation(csvText) {
    const errorLog = document.getElementById("errorLog");
    errorLog.innerHTML = "";
    errorLog.style.borderColor = "transparent";
    errorLog.style.backgroundColor = "transparent";
    const selectedType = document.getElementById("uldSelect").value;
    const selectedData = ulds[selectedType];
    const allowStacking = document.getElementById("chkStackable").checked;
    const rawItems = parseCSV(csvText);
    
    // Run packing
    const result = packItems(selectedData, rawItems, allowStacking);
    allPalletLoads = result.loads;
    globalOversizedItems = result.remaining;

    // Warning UI logic
    let htmlOutput = "";
    if (globalOversizedItems.length > 0) {
        errorLog.style.borderColor = "#d32f2f"; errorLog.style.backgroundColor = "#ffebee";
        htmlOutput += `<div style="color:#d32f2f; margin-bottom:10px;"><strong>‚ùå specification Mismatch:</strong><br>`;
        globalOversizedItems.forEach(i => htmlOutput += `‚Ä¢ Crate #${i.id} (${i.l}x${i.d}x${i.h}) moved to Side Area.<br>`);
        htmlOutput += `</div>`;
    }
    errorLog.innerHTML = htmlOutput;

    renderResults(rawItems.length);
    drawCanvas();
    runOptimizationEngine(rawItems, allowStacking, selectedType);
  }

  function runOptimizationEngine(items, allowStacking, currentType) {
    let stats = [];
    for (const key in ulds) {
       const uld = ulds[key];
       const result = packItems(uld, items, allowStacking);
       let totalFloorArea = 0; let usedFloorArea = 0;
       result.loads.forEach(p => { totalFloorArea += (p.uldW * p.uldL); p.stacks.forEach(s => { usedFloorArea += (s.visualW * s.visualH); }); });
       const floorEff = totalFloorArea > 0 ? (usedFloorArea / totalFloorArea) * 100 : 0;
       stats.push({ type: key, count: result.loads.length, remaining: result.remaining.length, floorEff: floorEff, isCurrent: (key === currentType) });
    }
    stats.sort((a,b) => (a.remaining - b.remaining) || (a.count - b.count) || (b.floorEff - a.floorEff));
    const best = stats[0];
    const panel = document.getElementById("optimizationPanel");
    panel.style.display = "block";
    if (best.type === currentType) {
        panel.className = "suggestion-box suggest-good";
        panel.innerHTML = `<span class="suggestion-header">‚úÖ Optimal Choice</span>Current selection is most efficient.`;
    } else {
        panel.className = "suggestion-box suggest-better";
        panel.innerHTML = `<span class="suggestion-header">üí° Try <u>${best.type}</u></span>Reduced pallets or better fit.`;
    }
  }

  function renderResults(totalItems) {
    const tbody = document.getElementById("resultTable").querySelector("tbody");
    tbody.innerHTML = "";
    let totalCargoVol = 0; let totalUldVol = 0;
    
    allPalletLoads.forEach((pallet, pIdx) => {
      totalUldVol += (pallet.uldW * pallet.uldL * pallet.uldH);
      pallet.stacks.forEach(stack => {
        stack.items.forEach((item, idx) => {
           totalCargoVol += (item.l * item.d * item.h);
           let tag = stack.items.length > 1 ? (idx === 0 ? "<strong>Bottom</strong>" : "<strong>Top</strong>") : "-";
           tbody.innerHTML += `<tr><td>#${pIdx+1}</td><td>${pallet.uldName}</td><td>${item.id}</td><td>${item.visualW}x${item.visualH}x${item.h}</td><td>${tag}</td></tr>`;
        });
      });
    });

    globalOversizedItems.forEach(item => {
        tbody.innerHTML += `<tr style="background:#fff1f0"><td>Side</td><td>INVALID</td><td>${item.id}</td><td>${item.l}x${item.d}x${item.h}</td><td>-</td></tr>`;
    });

    if(totalItems) document.getElementById("statTotalItems").innerText = totalItems;
    document.getElementById("statPalletCount").innerText = allPalletLoads.length;
    const eff = totalUldVol > 0 ? (totalCargoVol / totalUldVol)*100 : 0;
    document.getElementById("statEfficiency").innerText = eff.toFixed(1) + "%";
  }

  function drawCanvas() {
    const wrapper = document.getElementById("canvasWrapper");
    const canvas = document.getElementById("loadCanvas");
    const ctx = canvas.getContext("2d");
    let maxULDL = 0; allPalletLoads.forEach(p => { if(p.uldL > maxULDL) maxULDL = p.uldL; });
    globalScale = Math.min((wrapper.clientHeight - 80) / Math.max(maxULDL, 200), 1.2); 

    let currentX = PADDING; 
    allPalletLoads.forEach(p => { currentX += (p.uldW * globalScale) + GAP; });
    
    // Add space for the Oversized Area on the right
    const oversizedAreaWidth = globalOversizedItems.length > 0 ? 250 : 0;
    canvas.width = currentX + oversizedAreaWidth; 
    canvas.height = Math.max((maxULDL * globalScale) + PADDING + 60, 500); 

    let offsetX = PADDING; 
    
    // Draw Pallets
    allPalletLoads.forEach((pallet, idx) => {
      const pDrawW = pallet.uldW * globalScale; const pDrawH = pallet.uldL * globalScale;
      pallet._screenX = offsetX; pallet._screenW = pDrawW; pallet._screenH = pDrawH;
      
      ctx.fillStyle = "#0f4c81"; ctx.font = "bold 18px Arial"; ctx.fillText(`Pallet #${idx+1}`, offsetX, 25);
      ctx.fillStyle = "#e3f2fd"; ctx.lineWidth = 3; ctx.strokeStyle = pallet.isSmartFit ? "#2e7d32" : "#0f4c81"; 
      ctx.fillRect(offsetX, BOX_START_Y, pDrawW, pDrawH); ctx.strokeRect(offsetX, BOX_START_Y, pDrawW, pDrawH);
      
      pallet.stacks.forEach(stack => {
        if (isDragging && draggedStack === stack) return;
        if (isDragging && draggedItem && originalStack === stack) {
          // Draw only the items that are NOT being dragged
          drawStackExcludingItem(ctx, stack, offsetX + (stack.x * globalScale), BOX_START_Y + (stack.y * globalScale), draggedItem);
        } else {
          drawStack(ctx, stack, offsetX + (stack.x * globalScale), BOX_START_Y + (stack.y * globalScale));
        }
      });
      offsetX += pDrawW + GAP;
    });

    // Draw Invalid Area on the right (without outer border)
    if (globalOversizedItems.length > 0) {
        const invalidStartX = offsetX;
        invalidAreaBounds = {
          x: invalidStartX,
          y: BOX_START_Y,
          w: 200,
          h: canvas.height - 100
        };
        
        ctx.fillStyle = "#d32f2f"; ctx.font = "bold 18px Arial"; ctx.fillText("Invalid Cargo Area", offsetX, 25);
        ctx.fillStyle = "#fff1f0";
        ctx.fillRect(offsetX, BOX_START_Y, 200, canvas.height - 100);

        globalOversizedItems.forEach((item, idx) => {
            if (isDraggingInvalid && draggedInvalidItem === item) return; // Skip dragged item
            
            if (!item._invalidX) item._invalidX = 10;
            if (!item._invalidY) item._invalidY = 10 + (idx * 80);
            
            const w = Math.min(item.l, item.d) * (globalScale * 0.5); 
            const h = Math.max(item.l, item.d) * (globalScale * 0.5);
            
            ctx.fillStyle = "white"; ctx.strokeStyle = "#d32f2f"; ctx.lineWidth = 2;
            ctx.fillRect(offsetX + item._invalidX, BOX_START_Y + item._invalidY, w, h);
            ctx.strokeRect(offsetX + item._invalidX, BOX_START_Y + item._invalidY, w, h);
            ctx.fillStyle = "black"; ctx.font = "bold 10px Arial";
            ctx.fillText(`#${item.id}`, offsetX + item._invalidX + 5, BOX_START_Y + item._invalidY + 15);
            ctx.fillText(`${item.l}x${item.d}x${item.h}`, offsetX + item._invalidX + 5, BOX_START_Y + item._invalidY + 28);
        });
    }

    // Draw dragged item/stack
    if (isDragging && draggedStack) {
        drawStack(ctx, draggedStack, ghostGlobalPos.x, ghostGlobalPos.y, isCurrentPosInvalid);
    } else if (isDragging && draggedItem) {
        drawSingleItem(ctx, draggedItem, ghostGlobalPos.x, ghostGlobalPos.y, isCurrentPosInvalid);
    } else if (isDraggingInvalid && draggedInvalidItem) {
        const w = Math.min(draggedInvalidItem.l, draggedInvalidItem.d) * (globalScale * 0.5);
        const h = Math.max(draggedInvalidItem.l, draggedInvalidItem.d) * (globalScale * 0.5);
        ctx.fillStyle = "white"; ctx.strokeStyle = "#d32f2f"; ctx.lineWidth = 2;
        ctx.shadowBlur = 10; ctx.shadowColor = "rgba(0,0,0,0.3)";
        ctx.fillRect(ghostGlobalPos.x, ghostGlobalPos.y, w, h);
        ctx.strokeRect(ghostGlobalPos.x, ghostGlobalPos.y, w, h);
        ctx.shadowBlur = 0;
        ctx.fillStyle = "black"; ctx.font = "bold 10px Arial";
        ctx.fillText(`#${draggedInvalidItem.id}`, ghostGlobalPos.x + 5, ghostGlobalPos.y + 15);
        ctx.fillText(`${draggedInvalidItem.l}x${draggedInvalidItem.d}x${draggedInvalidItem.h}`, ghostGlobalPos.x + 5, ghostGlobalPos.y + 28);
    }
  }

  function drawStack(ctx, stack, x, y, isInvalid = false) {
     stack.items.forEach((item, itemIdx) => {
        const w = item.visualW * globalScale; const h = item.visualH * globalScale;
        ctx.fillStyle = isInvalid ? "#ffebee" : "white";
        if (isInvalid) { ctx.shadowBlur = 10; ctx.shadowColor = "red"; }
        ctx.fillRect(x, y, w, h);
        ctx.shadowBlur = 0; 
        ctx.strokeStyle = itemIdx === 0 ? "black" : "blue";
        if (itemIdx > 0) ctx.setLineDash([5, 3]);
        ctx.strokeRect(x, y, w, h);
        ctx.setLineDash([]);
    });
    
    let fs = stack.visualW * globalScale < 60 ? 9 : 11; ctx.font = `bold ${fs}px Arial`;
    let ty = y + 2;
    [...stack.items].reverse().forEach((item, i) => {
        let labelSuffix = stack.items.length > 1 ? (i === 0 ? "(‰∏ä)" : "(‰∏ã)") : "";
        ctx.fillStyle = stack.items.length > 1 ? (i===0 ? "red" : "blue") : "black";
        let label = `${item.id}${labelSuffix}. ${item.l}x${item.d}x${item.h}`;
        ctx.fillText(label, x+2, ty + fs);
        ty += (fs * 2.8);
    });
  }

  function drawStackExcludingItem(ctx, stack, x, y, excludeItem) {
    const remainingItems = stack.items.filter(item => item !== excludeItem);
    if (remainingItems.length === 0) return;
    
    remainingItems.forEach((item, itemIdx) => {
        const w = item.visualW * globalScale; const h = item.visualH * globalScale;
        ctx.fillStyle = "white";
        ctx.fillRect(x, y, w, h);
        ctx.strokeStyle = "black"; // Draw remaining items as regular (not stacked)
        ctx.strokeRect(x, y, w, h);
    });
    
    let fs = stack.visualW * globalScale < 60 ? 9 : 11; ctx.font = `bold ${fs}px Arial`;
    let ty = y + 2;
    [...remainingItems].reverse().forEach((item) => {
        ctx.fillStyle = "black"; // Draw as regular item
        let label = `${item.id}. ${item.l}x${item.d}x${item.h}`;
        ctx.fillText(label, x+2, ty + fs);
        ty += (fs * 2.8);
    });
  }

  function drawSingleItem(ctx, item, x, y, isInvalid = false) {
    const w = item.visualW * globalScale; const h = item.visualH * globalScale;
    ctx.fillStyle = isInvalid ? "#ffebee" : "white";
    if (isInvalid) { ctx.shadowBlur = 10; ctx.shadowColor = "red"; }
    ctx.fillRect(x, y, w, h);
    ctx.shadowBlur = 0; 
    ctx.strokeStyle = "black"; // Draw as regular item (not stacked)
    ctx.strokeRect(x, y, w, h);
    
    let fs = w < 60 ? 9 : 11; ctx.font = `bold ${fs}px Arial`;
    ctx.fillStyle = "black"; // Draw as regular item
    let label = `${item.id}. ${item.l}x${item.d}x${item.h}`;
    ctx.fillText(label, x+2, y + fs + 2);
  }

  function initInteractions() {
    const canvas = document.getElementById("loadCanvas");
    canvas.addEventListener("mousedown", handleMouseDown);
    window.addEventListener("mousemove", handleMouseMove);
    window.addEventListener("mouseup", handleMouseUp);
  }

  function getMousePos(e) {
    const rect = document.getElementById("loadCanvas").getBoundingClientRect();
    return { x: e.clientX - rect.left, y: e.clientY - rect.top };
  }

  function handleMouseDown(e) {
    const pos = getMousePos(e);
    
    // Check invalid cargo area first
    if (invalidAreaBounds && globalOversizedItems.length > 0) {
      globalOversizedItems.forEach(item => {
        if (!item._invalidX) item._invalidX = 10;
        if (!item._invalidY) item._invalidY = 10;
        
        const w = Math.min(item.l, item.d) * (globalScale * 0.5);
        const h = Math.max(item.l, item.d) * (globalScale * 0.5);
        const ix = invalidAreaBounds.x + item._invalidX;
        const iy = BOX_START_Y + item._invalidY;
        
        if (pos.x >= ix && pos.x <= ix + w && pos.y >= iy && pos.y <= iy + h) {
          isDraggingInvalid = true;
          draggedInvalidItem = item;
          dragOffset.x = pos.x - ix;
          dragOffset.y = pos.y - iy;
          document.getElementById("loadCanvas").style.cursor = "grabbing";
          return;
        }
      });
    }
    
    // Check pallets
    allPalletLoads.forEach(pallet => {
      pallet.stacks.forEach((stack) => {
        const sx = pallet._screenX + (stack.x * globalScale);
        const sy = BOX_START_Y + (stack.y * globalScale);
        const sw = stack.visualW * globalScale;
        const sh = stack.visualH * globalScale;
        
        if (pos.x >= sx && pos.x <= sx + sw && pos.y >= sy && pos.y <= sy + sh) {
          // Check if clicking on top item of a stack
          if (stack.items.length > 1) {
            const topItem = stack.items[stack.items.length - 1];
            // Allow dragging the top item individually
            isDragging = true;
            draggedItem = topItem;
            originalStack = stack;
            draggedPallet = pallet;
            originalPallet = pallet;
            originalPos = { x: stack.x, y: stack.y };
            dragOffset.x = (pos.x - sx);
            dragOffset.y = (pos.y - sy);
            document.getElementById("loadCanvas").style.cursor = "grabbing";
          } else {
            // Single item stack - drag the whole stack
            isDragging = true;
            draggedStack = stack;
            draggedPallet = pallet;
            originalPallet = pallet;
            originalPos = { x: stack.x, y: stack.y };
            dragOffset.x = (pos.x - sx);
            dragOffset.y = (pos.y - sy);
            document.getElementById("loadCanvas").style.cursor = "grabbing";
          }
        }
      });
    });
  }

  function handleMouseMove(e) {
    if (isDraggingInvalid && draggedInvalidItem) {
      const pos = getMousePos(e);
      ghostGlobalPos.x = pos.x - dragOffset.x;
      ghostGlobalPos.y = pos.y - dragOffset.y;
      drawCanvas();
      return;
    }
    
    if (!isDragging || (!draggedStack && !draggedItem)) return;
    
    const pos = getMousePos(e);
    ghostGlobalPos.x = pos.x - dragOffset.x;
    ghostGlobalPos.y = pos.y - dragOffset.y;
    
    let targetPallet = null;
    allPalletLoads.forEach(p => { 
      if (pos.x >= p._screenX && pos.x <= p._screenX + p._screenW) targetPallet = p; 
    });
    
    if (targetPallet) {
      draggedPallet = targetPallet;
      if (draggedStack) {
        draggedStack.x = (ghostGlobalPos.x - targetPallet._screenX) / globalScale;
        draggedStack.y = (ghostGlobalPos.y - BOX_START_Y) / globalScale;
      } else if (draggedItem) {
        draggedItem.x = (ghostGlobalPos.x - targetPallet._screenX) / globalScale;
        draggedItem.y = (ghostGlobalPos.y - BOX_START_Y) / globalScale;
      }
    }
    
    checkValidity();
    drawCanvas();
  }

  function checkValidity() {
    isCurrentPosInvalid = false;
    const p = draggedPallet;
    
    if (draggedStack) {
      const s = draggedStack;
      if (s.x < 0 || s.y < 0 || (s.x + s.visualW) > p.uldW || (s.y + s.visualH) > p.uldL) {
        isCurrentPosInvalid = true;
      }
      if (!isCurrentPosInvalid) {
        for (let other of p.stacks) {
          if (other === s) continue;
          if (s.x < other.x + other.visualW && s.x + s.visualW > other.x && 
              s.y < other.y + other.visualH && s.y + s.visualH > other.y) {
            isCurrentPosInvalid = true;
            break;
          }
        }
      }
    } else if (draggedItem) {
      const item = draggedItem;
      if (item.x < 0 || item.y < 0 || (item.x + item.visualW) > p.uldW || (item.y + item.visualH) > p.uldL) {
        isCurrentPosInvalid = true;
      }
      if (!isCurrentPosInvalid) {
        for (let stack of p.stacks) {
          if (stack === originalStack) continue; // Don't check against original position
          if (item.x < stack.x + stack.visualW && item.x + item.visualW > stack.x && 
              item.y < stack.y + stack.visualH && item.y + item.visualH > stack.y) {
            isCurrentPosInvalid = true;
            break;
          }
        }
      }
    }
  }

  function handleMouseUp() {
    if (isDraggingInvalid && draggedInvalidItem) {
      // Update position within invalid area
      if (invalidAreaBounds) {
        const relX = ghostGlobalPos.x - invalidAreaBounds.x;
        const relY = ghostGlobalPos.y - BOX_START_Y;
        
        // Keep within bounds
        const w = Math.min(draggedInvalidItem.l, draggedInvalidItem.d) * (globalScale * 0.5);
        const h = Math.max(draggedInvalidItem.l, draggedInvalidItem.d) * (globalScale * 0.5);
        
        if (relX >= 0 && relX + w <= invalidAreaBounds.w && relY >= 0 && relY + h <= invalidAreaBounds.h) {
          draggedInvalidItem._invalidX = relX;
          draggedInvalidItem._invalidY = relY;
        }
      }
      
      isDraggingInvalid = false;
      draggedInvalidItem = null;
      document.getElementById("loadCanvas").style.cursor = "default";
      drawCanvas();
      return;
    }
    
    if (!isDragging || (!draggedStack && !draggedItem)) return;
    
    checkValidity();
    
    if (draggedItem) {
      // Handle individual item drop
      if (isCurrentPosInvalid) {
        // Return to original position
        draggedItem.x = originalPos.x;
        draggedItem.y = originalPos.y;
        draggedPallet = originalPallet;
      } else {
        // Remove from original stack
        originalStack.items = originalStack.items.filter(item => item !== draggedItem);
        
        // If original stack is now empty, remove it
        if (originalStack.items.length === 0) {
          originalPallet.stacks = originalPallet.stacks.filter(s => s !== originalStack);
        } else {
          // Update original stack height
          originalStack.currentH = originalStack.items.reduce((sum, item) => sum + item.h, 0);
        }
        
        // Create new stack for dropped item on target pallet
        if (draggedPallet !== originalPallet) {
          draggedPallet.stacks.push({
            x: draggedItem.x,
            y: draggedItem.y,
            visualW: draggedItem.visualW,
            visualH: draggedItem.visualH,
            currentH: draggedItem.h,
            items: [draggedItem]
          });
        } else {
          // Same pallet, create new stack
          draggedPallet.stacks.push({
            x: draggedItem.x,
            y: draggedItem.y,
            visualW: draggedItem.visualW,
            visualH: draggedItem.visualH,
            currentH: draggedItem.h,
            items: [draggedItem]
          });
        }
        
        draggedItem.z = 0; // Reset z position (floor level)
      }
      
      draggedItem = null;
      originalStack = null;
    } else if (draggedStack) {
      // Handle whole stack drop
      if (isCurrentPosInvalid) {
        draggedStack.x = originalPos.x;
        draggedStack.y = originalPos.y;
        draggedPallet = originalPallet;
      } else if (draggedPallet !== originalPallet) {
        originalPallet.stacks = originalPallet.stacks.filter(item => item !== draggedStack);
        draggedPallet.stacks.push(draggedStack);
      }
      
      draggedStack = null;
    }
    
    isDragging = false;
    draggedPallet = null;
    originalPallet = null;
    document.getElementById("loadCanvas").style.cursor = "default";
    renderResults();
    drawCanvas();
  }

  async function downloadPDF() {
    const { jsPDF } = window.jspdf;
    const btn = document.getElementById('btnDownloadPDF');
    btn.innerText = "Processing..."; btn.disabled = true;
    try {
        const visualCanvas = await html2canvas(document.getElementById('export-visual'), { scale: 2 });
        const manifestTable = await html2canvas(document.getElementById('resultTable'), { scale: 2 });
        const pdf = new jsPDF('l', 'mm', 'a4');
        const pWidth = pdf.internal.pageSize.getWidth();
        const pHeight = pdf.internal.pageSize.getHeight();
        const availableWidth = pWidth - 20;
        pdf.setFontSize(16); pdf.setTextColor(15, 76, 129); pdf.text("Pallet Load Plan Report", 10, 12);
        const vRatio = availableWidth / visualCanvas.width;
        const vHeight = visualCanvas.height * vRatio;
        pdf.addImage(visualCanvas.toDataURL('image/png'), 'PNG', 10, 22, availableWidth, vHeight);
        pdf.addPage('l', 'mm', 'a4'); pdf.text("Manifest Details", 10, 12);
        const mRatio = availableWidth / manifestTable.width;
        const mHeight = manifestTable.height * mRatio;
        pdf.addImage(manifestTable.toDataURL('image/png'), 'PNG', 10, 20, availableWidth, mHeight);
        pdf.save(`Pallet_Report_${Date.now()}.pdf`);
    } catch (e) { alert("PDF Error"); }
    finally { btn.innerText = "Download Visual & Manifest PDF"; btn.disabled = false; }
  }
</script>
</body>
</html>
